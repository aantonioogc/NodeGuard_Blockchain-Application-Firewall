<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>NodeGuard Dashboard - Security Analytics</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üõ°Ô∏è</text></svg>">
    <style>
        /* --- estilos --- (id√©nticos a la versi√≥n anterior, s√≥lo recortados aqu√≠ por brevedad) */
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Segoe UI',Tahoma,Arial; background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:#333; line-height:1.6}
        .container{max-width:1400px;margin:0 auto;padding:20px}
        .header{background:rgba(255,255,255,.95);backdrop-filter:blur(10px);padding:20px;border-radius:15px;margin-bottom:30px;box-shadow:0 8px 32px rgba(0,0,0,.1);text-align:center}
        .header h1{color:#2c3e50;font-size:2.5rem;margin-bottom:10px}
        .header .subtitle{color:#7f8c8d;font-size:1.1rem}
        .status-bar{display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,.9);padding:15px 20px;border-radius:10px;margin-bottom:30px;box-shadow:0 4px 16px rgba(0,0,0,.1)}
        .status-item{display:flex;align-items:center;gap:10px}
        .status-indicator{width:12px;height:12px;border-radius:50%;animation:pulse 2s infinite}
        .status-indicator.online{background:#27ae60}
        .status-indicator.offline{background:#e74c3c}
        @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.1);opacity:.7}100%{transform:scale(1);opacity:1}}
        .dashboard-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:20px;margin-bottom:30px}
        .card{background:rgba(255,255,255,.95);backdrop-filter:blur(10px);border-radius:15px;padding:25px;box-shadow:0 8px 32px rgba(0,0,0,.1);transition:transform .3s,box-shadow .3s}
        .card:hover{transform:translateY(-5px);box-shadow:0 12px 40px rgba(0,0,0,.15)}
        .card-header{display:flex;align-items:center;margin-bottom:20px;padding-bottom:15px;border-bottom:2px solid #ecf0f1}
        .card-icon{font-size:2rem;margin-right:15px}
        .card-title{font-size:1.3rem;font-weight:600;color:#2c3e50}
        .metric{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid #ecf0f1}
        .metric:last-child{border-bottom:none}
        .metric-label{font-weight:500;color:#34495e}
        .metric-value{font-weight:700;font-size:1.1rem}
        .metric-value.success{color:#27ae60}
        .metric-value.danger{color:#e74c3c}
        .metric-value.warning{color:#f39c12}
        .donut-chart-container{position:relative;height:auto;min-height:200px;max-height:450px;width:100%;display:flex;align-items:flex-start;justify-content:center;overflow-y:auto;overflow-x:hidden;padding:15px 10px;background:linear-gradient(135deg,#f8f9fa 0%,#e9ecef 100%);border-radius:8px;border:1px solid #dee2e6}
        .attackers-table{width:100%;border-collapse:collapse;margin-top:15px}
        .attackers-table th,.attackers-table td{text-align:left;padding:12px 8px;border-bottom:1px solid #ecf0f1}
        .attackers-table th{background:#f8f9fa;font-weight:600;color:#2c3e50}
        .threat-level{padding:4px 12px;border-radius:20px;font-size:.85rem;font-weight:600}
        .threat-level.high{background:#ffebee;color:#c62828}
        .threat-level.medium{background:#fff3e0;color:#ef6c00}
        .threat-level.low{background:#e8f5e8;color:#2e7d32}
        .events-feed{max-height:400px;overflow-y:auto;margin-top:15px}
        .event-item{padding:12px;border-left:4px solid #3498db;background:#f8f9fa;margin-bottom:10px;border-radius:0 8px 8px 0;font-family:'Courier New',monospace;font-size:.9rem}
        .event-item.block{border-left-color:#e74c3c;background:#fdf2f2}
        .event-item.allow{border-left-color:#27ae60;background:#f0f9f0}
        .event-time{color:#7f8c8d;font-size:.8rem}
        .control-panel{background:rgba(255,255,255,.95);backdrop-filter:blur(10px);border-radius:15px;padding:25px;box-shadow:0 8px 32px rgba(0,0,0,.1)}
        .button{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:600;transition:all .3s;margin:5px}
        .button.secondary{background:linear-gradient(135deg,#95a5a6 0%,#7f8c8d 100%)}
        .button.danger{background:linear-gradient(135deg,#e74c3c 0%,#c0392b 100%)}
        .loading{display:inline-block;width:20px;height:20px;border:3px solid #f3f3f3;border-top:3px solid #3498db;border-radius:50%;animation:spin 1s linear infinite}
        @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
        @media (max-width:768px){.dashboard-grid{grid-template-columns:1fr}.status-bar{flex-direction:column;gap:15px}.header h1{font-size:2rem}}
        .toast{position:fixed;top:20px;right:20px;background:#2c3e50;color:white;padding:15px 20px;border-radius:8px;z-index:1000;transform:translateX(400px);transition:transform .3s}
        .toast.show{transform:translateX(0)}.toast.success{background:#27ae60}.toast.error{background:#e74c3c}.toast.warning{background:#f39c12}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è NodeGuard Security Dashboard</h1>
            <div class="subtitle">Blockchain Application Firewall - Real-time Security Analytics</div>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator online" id="server-status"></div>
                <span>Server: <strong id="server-text">Loading...</strong></span>
            </div>
            <div class="status-item">
                <div class="status-indicator online" id="redis-status"></div>
                <span>Redis: <strong id="redis-text">Loading...</strong></span>
            </div>
            <div class="status-item">
                <div class="status-indicator online" id="upstream-status"></div>
                <span>RPC: <strong id="upstream-text">Loading...</strong></span>
            </div>
            <div class="status-item">
                <span>Mode: <strong id="enforcement-mode">Loading...</strong></span>
            </div>
            <div class="status-item">
                <span>Uptime: <strong id="uptime">Loading...</strong></span>
            </div>
            <div class="status-item">
                <button class="button" onclick="refreshData()" style="padding:8px 16px;font-size:14px">üîÑ Refresh Now</button>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="card">
                <div class="card-header">
                    <span class="card-icon">üìä</span>
                    <span class="card-title">Security Metrics</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Requests</span>
                    <span class="metric-value info" id="total-requests"><div class="loading"></div></span>
                </div>
                <div class="metric">
                    <span class="metric-label">Blocked Attacks</span>
                    <span class="metric-value danger" id="blocked-requests"><div class="loading"></div></span>
                </div>
                <div class="metric">
                    <span class="metric-label">Allowed Requests</span>
                    <span class="metric-value success" id="allowed-requests"><div class="loading"></div></span>
                </div>
                <div class="metric">
                    <span class="metric-label">Block Rate</span>
                    <span class="metric-value warning" id="block-rate"><div class="loading"></div></span>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-icon">üéØ</span>
                    <span class="card-title">Top 5 Attackers</span>
                </div>
                <table class="attackers-table">
                    <thead>
                        <tr><th>IP Address</th><th>Score</th><th>Attacks</th><th>Threat</th></tr>
                    </thead>
                    <tbody id="top-attackers">
                        <tr><td colspan="4" style="text-align:center;color:#7f8c8d">No attack data available</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-icon">üç©</span>
                    <span class="card-title">Attack Distribution</span>
                </div>
                <div class="donut-chart-container">
                    <div id="attackDistribution" style="padding:20px;text-align:center;color:#888">No attack data for this session</div>
                </div>
            </div>
        </div>

        <div class="live-events-section">
            <div class="card">
                <div class="card-header">
                    <span class="card-icon">üî¥</span>
                    <span class="card-title">Live Events</span>
                </div>
                <div class="events-feed" id="events-feed">
                    <div class="event-item"><div class="event-time">Waiting for events...</div></div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <div class="card-header">
                <span class="card-icon">üéõÔ∏è</span>
                <span class="card-title">Security Controls</span>
            </div>

            <button class="button secondary" onclick="exportMetrics()">üìà Export Metrics</button>
            <button class="button secondary" onclick="testConnection()">üîå Test Connection</button>
            <button class="button danger" onclick="clearEvents()">üóëÔ∏è Clear Events</button>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
    /*****************************************************************
     * Archivo actualizado: comportamiento estricto sobre "fresh start"
     * - Las m√©tricas permanecen en 0 hasta que /api/analytics/reset-session
     *   responda OK (serverResetDone === true).
     * - Top attackers / distribution tambi√©n est√°n bloqueadas hasta OK.
     * - SSE sigue conectando y mostrando eventos (si quieres bloquearlo, lo cambio).
     *****************************************************************/

    window.dashboardState = {
        sessionId: Date.now(),
        serverResetDone: false      // <-- estrictamente necesario para permitir mostrar m√©tricas
    };

    let adminToken = localStorage.getItem('adminToken') || 'test-admin-token-123';
    let eventSource = null;

    function showToast(msg, type='info') {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.className = `toast ${type} show`;
        setTimeout(()=> toast.className = 'toast', 3000);
    }

    function formatTime(ts){ return new Date(ts).toLocaleTimeString(); }
    function getThreatLevel(score){ if(score>=80) return 'high'; if(score>=40) return 'medium'; return 'low'; }
    function formatIPFull(ip){ return ip || ''; }

    async function apiRequest(endpoint, options={}) {
        const url = endpoint.startsWith('http') ? endpoint : `${window.location.origin}${endpoint}`;
        const opts = { method: 'GET', headers: { 'Content-Type':'application/json', 'x-admin-token': adminToken, 'Cache-Control':'no-cache' }, ...options };
        const resp = await fetch(url, opts);
        if (!resp.ok) {
            const text = await resp.text().catch(()=> '');
            throw new Error(`HTTP ${resp.status}: ${text}`);
        }
        return resp.json().catch(()=> ({}));
    }

    // --------- Strict reset: only allow metrics update after successful reset ----------
    async function clearServerData() {
        try {
            const resp = await fetch('/api/analytics/reset-session', {
                method: 'POST',
                headers: { 'Content-Type':'application/json', 'x-admin-token': adminToken },
                body: JSON.stringify({ sessionId: window.dashboardState.sessionId })
            });

            if (resp.ok) {
                // If server returns JSON we can inspect it; but we treat OK as confirmation.
                window.dashboardState.serverResetDone = true;
                console.log('Server reset acknowledged (OK). Metrics will be updated from now on.');
                showToast('Server session reset acknowledged ‚Äî showing live metrics', 'success');
            } else {
                // Do NOT allow automatic overwrite: keep metrics at 0.
                window.dashboardState.serverResetDone = false;
                console.warn('Server reset endpoint returned non-ok; keeping metrics at 0.');
                showToast('Advertencia: reset-session no OK ‚Äî m√©tricas permanecer√°n en 0', 'warning');
            }
        } catch (err) {
            window.dashboardState.serverResetDone = false;
            console.warn('Error calling reset endpoint; keeping metrics at 0.', err);
            showToast('Reset endpoint no disponible ‚Äî m√©tricas permanecen en 0', 'warning');
        }
    }

    function resetMetricsToZero() {
        document.getElementById('total-requests').textContent = (0).toLocaleString();
        document.getElementById('blocked-requests').textContent = (0).toLocaleString();
        document.getElementById('allowed-requests').textContent = (0).toLocaleString();
        document.getElementById('block-rate').textContent = '0%';
        document.getElementById('uptime').textContent = '0s';
        document.getElementById('enforcement-mode').textContent = 'N/A';
        document.getElementById('top-attackers').innerHTML = '<tr><td colspan="4" style="text-align:center;color:#7f8c8d">No attack data available</td></tr>';
        document.getElementById('attackDistribution').innerHTML = '<div style="padding:40px;color:#888;text-align:center">No attacks detected in this session</div>';
    }

    async function fetchSystemStatus() {
        try {
            const health = await fetch('/healthz').then(r => r.ok ? r.json() : {});
            const landing = await fetch('/').then(r => r.ok ? r.json() : {});

            // update indicators always
            updateStatusIndicator('server', Boolean(health.services?.server));
            updateStatusIndicator('redis', Boolean(health.services?.redis));
            updateStatusIndicator('upstream', Boolean(health.services?.upstream));

            // only update metrics if server reset has been confirmed
            if (!window.dashboardState.serverResetDone) {
                console.log('Server reset not confirmed yet: leaving metrics at 0');
                return;
            }

            const metrics = landing.metrics || {};
            document.getElementById('total-requests').textContent = (metrics.totalRequests || 0).toLocaleString();
            document.getElementById('blocked-requests').textContent = (metrics.blockedRequests || 0).toLocaleString();
            document.getElementById('allowed-requests').textContent = (metrics.allowedRequests || 0).toLocaleString();
            let blockRate = metrics.blockRate;
            if (typeof blockRate === 'number') blockRate = `${blockRate}%`;
            document.getElementById('block-rate').textContent = blockRate || '0%';

            document.getElementById('uptime').textContent = landing.uptime?.formatted || '0s';
            document.getElementById('enforcement-mode').textContent = (landing.security?.enforcement || 'N/A').toUpperCase();

        } catch (err) {
            console.error('fetchSystemStatus error', err);
            // keep metrics at zero if error
        }
    }

    async function fetchTopAttackers() {
        if (!window.dashboardState.serverResetDone) {
            console.log('Server reset not confirmed: skipping top attackers fetch');
            return;
        }
        try {
            const resp = await apiRequest('/api/analytics/top-attackers?limit=5');
            const attackers = resp.data || [];
            updateAttackersTable(attackers);
        } catch (err) {
            console.warn('Failed to load attackers', err);
        }
    }

    function updateAttackersTable(attackers) {
        const tbody = document.getElementById('top-attackers');
        if (!attackers || attackers.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#7f8c8d">No attackers detected</td></tr>';
            return;
        }
        tbody.innerHTML = attackers.map(a => `
            <tr>
                <td><code>${formatIPFull(a.ip)}</code></td>
                <td><strong>${a.score}</strong></td>
                <td>${a.attacks}</td>
                <td><span class="threat-level ${getThreatLevel(a.score)}">${getThreatLevel(a.score).toUpperCase()}</span></td>
            </tr>
        `).join('');
    }

    async function fetchAndDisplayAttackDistribution() {
        if (!window.dashboardState.serverResetDone) {
            console.log('Server reset not confirmed: skipping attack distribution fetch');
            return;
        }
        try {
            const resp = await apiRequest('/api/analytics/attack-reasons');
            const data = resp.data || {};
            displayAttackDistribution(data);
        } catch (err) {
            console.warn('Failed to load attack distribution', err);
        }
    }

    function displayAttackDistribution(data) {
        const container = document.getElementById('attackDistribution');
        if (!container) return;
        const entries = Object.entries(data || {});
        if (entries.length === 0) {
            container.innerHTML = '<div style="padding:40px;color:#888;text-align:center">No attacks detected in this session</div>';
            return;
        }
        const total = entries.reduce((s,[,c])=> s + c, 0);
        const sorted = entries.sort((a,b)=>b[1]-a[1]);
        let html = `<div style="padding:15px;width:100%;display:flex;flex-direction:column;align-items:center"><div style="margin-bottom:20px;font-size:1.2em;font-weight:600;color:#2c3e50">${total} Total Attacks</div><div style="display:flex;flex-wrap:wrap;justify-content:center;gap:15px;max-width:100%">`;
        sorted.forEach(([type,count])=>{
            const pct = ((count/total)*100).toFixed(1);
            const size = Math.max(60, Math.min(120, 60 + (count*8)));
            const rgb = getAttackTypeColor(type);
            const displayName = getDisplayName(type);
            html += `<div style="display:flex;flex-direction:column;align-items:center;margin:10px">
                        <div style="width:${size}px;height:${size}px;border-radius:50%;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;border:3px solid rgb(${rgb});background:linear-gradient(180deg,rgba(${rgb},.9),rgba(${rgb},.5))">
                            <div style="color:white;font-weight:bold;font-size:1.2em;z-index:2">${count}</div>
                            <div style="position:absolute;bottom:0;left:0;width:100%;height:${pct}%;background:rgba(${rgb},.35);border-radius:50% 50% 0 0"></div>
                        </div>
                        <div style="margin-top:8px;text-align:center;max-width:${size+20}px;font-size:.75em;font-weight:500;color:#2c3e50">${displayName}</div>
                    </div>`;
        });
        html += `</div></div>`;
        container.innerHTML = html;
    }

    function getAttackTypeColor(type) {
        const colors = {
            'rate_limit':'231,76,60','blocked_method':'230,126,34','invalid_transaction':'52,152,219',
            'dos_circuit_breaker_triggered':'155,89,182','fingerprint_detection':'26,188,156','transaction_mimicry':'46,204,113',
            'replay_attack':'241,196,15','gas_limit_exceeded':'192,57,43','reentrancy_attack':'142,68,173','mev_attack':'39,174,96',
            'sandwich_attack':'243,156,18','validation_failed':'127,140,141','malformed_request':'52,73,94'
        };
        return colors[type] || '149,165,166';
    }
    function getDisplayName(type){
        const names = {
            'rate_limit':'Rate Limit','blocked_method':'M√©todo Bloqueado','invalid_transaction':'Transacci√≥n Inv√°lida',
            'dos_circuit_breaker_triggered':'DoS Protection','fingerprint_detection':'Detecci√≥n Huella','transaction_mimicry':'Imitaci√≥n Transacci√≥n',
            'replay_attack':'Ataque Replay','gas_limit_exceeded':'Gas Excedido','reentrancy_attack':'Ataque Reentrancy','mev_attack':'Ataque MEV',
            'sandwich_attack':'Ataque Sandwich','validation_failed':'Validaci√≥n Fallida','malformed_request':'Petici√≥n Malformada'
        };
        return names[type] || type.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase());
    }

    // ------------- SSE -------------
    function initializeEventStream() {
        if (eventSource) { eventSource.close(); eventSource = null; }
        const feed = document.getElementById('events-feed');
        feed.innerHTML = `<div class="event-item"><div class="event-time">${formatTime(Date.now())}</div><div>üîÑ Connecting to live event stream...</div></div>`;
        try {
            eventSource = new EventSource(`/events?token=${encodeURIComponent(adminToken)}`);
            eventSource.onopen = ()=>{ feed.innerHTML = `<div class="event-item allow"><div class="event-time">${formatTime(Date.now())}</div><div>üü¢ Live Events active</div></div>`; showToast('Live Events connected','success'); };
            eventSource.onmessage = (evt)=>{ try{ const data = JSON.parse(evt.data); handleIncomingEvent(data); }catch(e){ console.error('SSE parse',e);} };
            eventSource.onerror = (err)=>{ console.error('SSE error',err); feed.innerHTML = `<div class="event-item block"><div class="event-time">${formatTime(Date.now())}</div><div>‚ùå Live Events connection error ‚Äî retrying...</div></div>`; setTimeout(initializeEventStream,3000); };
        } catch(e) { console.error('SSE init failed', e); feed.innerHTML = `<div class="event-item block"><div class="event-time">${formatTime(Date.now())}</div><div>‚ùå Failed to init Live Events</div></div>`; }
    }

    function handleIncomingEvent(event) {
        if (!event || event.type === 'ping' || event.type === 'connection') return;
        const feed = document.getElementById('events-feed');
        const el = document.createElement('div');
        el.className = (event.type==='block')?'event-item block':(event.type==='allow')?'event-item allow':'event-item';
        el.innerHTML = `<div class="event-time">${formatTime(event.timestamp||Date.now())}</div>
                        <div style="font-weight:500;margin:2px 0">${(event.type==='block')?'üö´':(event.type==='allow')?'‚úÖ':'üìù'} ${event.method||event.action||'event'} - ${event.reason||event.message||''}</div>
                        ${event.clientIp ? `<div style="font-size:.85em;color:#888;margin-top:3px">üìç Source: ${formatIPFull(event.clientIp)}${event.userAgent?` | üåê ${event.userAgent.split(' ')[0]}`:''}</div>` : ''}`;
        feed.appendChild(el);
        while(feed.children.length>100) feed.removeChild(feed.firstChild);
        feed.scrollTop = feed.scrollHeight;

        if (event.type==='block' || event.type==='allow') {
            clearTimeout(window.updateTimeout);
            window.updateTimeout = setTimeout(()=>{ 
                // Only fetch analytics if reset confirmed
                if (window.dashboardState.serverResetDone) {
                    Promise.allSettled([fetchSystemStatus(), fetchTopAttackers(), fetchAndDisplayAttackDistribution()]);
                }
            }, 2000);
        }
    }

    // ---------- Controls ----------
    function refreshData(){
        showToast('Refreshing dashboard...', 'info');
        // If reset not confirmed, only update status & try reset again
        if (!window.dashboardState.serverResetDone) {
            Promise.allSettled([ fetchSystemStatus() ]).then(()=> showToast('Refreshed (metrics still locked until reset).','info'));
            return;
        }
        Promise.allSettled([ fetchSystemStatus(), fetchTopAttackers(), fetchAndDisplayAttackDistribution() ]).then(()=> showToast('Dashboard refreshed','success'));
    }

    function exportMetrics(){
        const metrics = {
            timestamp: new Date().toISOString(),
            totalRequests: document.getElementById('total-requests').textContent,
            blockedRequests: document.getElementById('blocked-requests').textContent,
            allowedRequests: document.getElementById('allowed-requests').textContent,
            blockRate: document.getElementById('block-rate').textContent,
            uptime: document.getElementById('uptime').textContent
        };
        const b = new Blob([JSON.stringify(metrics,null,2)], { type:'application/json' });
        const u = URL.createObjectURL(b);
        const a = document.createElement('a'); a.href = u; a.download = `nodeguard-metrics-${Date.now()}.json`; a.click(); URL.revokeObjectURL(u);
        showToast('Metrics exported','success');
    }

    function clearEvents(){ if (!confirm('Clear events from display?')) return; document.getElementById('events-feed').innerHTML = '<div class="event-item"><div class="event-time">Events cleared</div></div>'; showToast('Events cleared','info'); }
    function testConnection(){
        showToast('Testing connections...', 'info');
        Promise.all([
            fetch('/healthz').then(r => r.ok? r.json():{}),
            fetch('/').then(r => r.ok? r.json():{})
        ]).then(()=> showToast('Connections test completed','success')).catch(e=> showToast('Connection test failed','error'));
    }

    function updateStatusIndicator(service, ok) {
        const ind = document.getElementById(`${service}-status`), txt = document.getElementById(`${service}-text`);
        if (!ind || !txt) return;
        ind.className = `status-indicator ${ok ? 'online' : 'offline'}`;
        txt.textContent = (service === 'server') ? (ok ? 'Online' : 'Offline') : (service === 'redis') ? (ok ? 'Connected' : 'Disconnected') : (ok ? 'Available' : 'Unavailable');
    }

    // ---------- Auto refresh ----------
    let intervals = {};
    function setupAutoRefresh(){
        if (intervals.status) clearInterval(intervals.status);
        if (intervals.analytics) clearInterval(intervals.analytics);
        intervals.status = setInterval(()=> fetchSystemStatus().catch(()=>{}), 15000);
        intervals.analytics = setInterval(()=> { if (window.dashboardState.serverResetDone) { fetchTopAttackers(); fetchAndDisplayAttackDistribution(); } }, 30000);
    }

    // ---------- Init ----------
    async function initDashboard(){
        showToast('Inicializando dashboard...', 'info');
        resetMetricsToZero(); // ensure zeros visible immediately
        // Attempt server reset: strict behavior - only on OK we allow metrics to populate
        await clearServerData();
        // Start SSE anyway (user asked events to show)
        initializeEventStream();
        // If serverResetDone is true right away, load analytics; otherwise leave metrics at zero
        if (window.dashboardState.serverResetDone) {
            await Promise.all([ fetchSystemStatus(), fetchTopAttackers(), fetchAndDisplayAttackDistribution() ]);
        } else {
            // Still fetch status to show indicators, but don't overwrite metrics
            await fetchSystemStatus();
        }
        setupAutoRefresh();
        showToast('Dashboard listo', 'success');
    }

    document.addEventListener('DOMContentLoaded', initDashboard);

    // cleanup
    window.addEventListener('beforeunload', ()=> {
        if (eventSource) { eventSource.close(); eventSource = null; }
        if (intervals.status) clearInterval(intervals.status);
        if (intervals.analytics) clearInterval(intervals.analytics);
    });

    </script>
</body>
</html>
